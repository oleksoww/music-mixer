<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ðŸŽ¶ Vocal / Beat Remover & Mixer (GitHub Pages)</title>
  <style>
    :root { --bg:#0b1020; --card:#121a36; --text:#e9ecf5; --muted:#9aa6ce; --accent:#7aa2f7; }
    *{box-sizing:border-box}
    body{margin:0; font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Arial; background:var(--bg); color:var(--text);}
    .wrap{max-width:980px; margin:0 auto; padding:32px 16px;}
    h1{font-size:28px; margin:0 0 16px}
    p.lead{color:var(--muted); margin:0 0 24px}
    .card{background:var(--card); border:1px solid rgba(255,255,255,.06); border-radius:16px; padding:20px; margin:16px 0; box-shadow:0 8px 30px rgba(0,0,0,.25)}
    .grid{display:grid; gap:16px}
    @media(min-width:860px){ .grid{grid-template-columns:1fr 1fr} }
    label{display:block; font-weight:600; margin-bottom:8px}
    input[type="file"], input[type="number"], input[type="range"]{width:100%}
    input[type="file"]{padding:10px; background:#0f1730; color:var(--muted); border:1px dashed rgba(255,255,255,.18); border-radius:12px}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .btn{appearance:none; border:0; background:var(--accent); color:#0b1020; font-weight:800; padding:12px 16px; border-radius:12px; cursor:pointer}
    .btn.secondary{background:#2c3964; color:var(--text)}
    .btn:disabled{opacity:.6; cursor:not-allowed}
    .mini{font-size:12px; color:var(--muted)}
    .status{margin-top:8px; color:var(--muted)}
    .audio{width:100%}
    .pill{display:inline-block; background:#1a244a; border:1px solid rgba(255,255,255,.1); color:var(--muted); padding:6px 10px; border-radius:999px; font-size:12px; margin-left:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ðŸŽ¶ Vocal / Beat Remover & Mixer</h1>
    <p class="lead">DziaÅ‚a w przeglÄ…darce (GitHub Pages). <span class="pill">bez backendu</span> <span class="pill">offline</span></p>

    <div class="card">
      <h2>1) Wgraj utwÃ³r ÅºrÃ³dÅ‚owy</h2>
      <label for="songFile">Plik audio (stereo zalecane)</label>
      <input id="songFile" type="file" accept="audio/*" />
      <div class="row" style="margin-top:12px">
        <button id="btnInstrumental" class="btn" disabled>UsuÅ„ wokal â†’ pobierz <b>instrumental.wav</b></button>
        <button id="btnVocals" class="btn secondary" disabled>UsuÅ„ beat â†’ pobierz <b>vocals.wav</b></button>
      </div>
      <div class="status" id="statusMain">Wybierz plik, a przyciski siÄ™ aktywujÄ….</div>
      <audio id="previewOriginal" class="audio" controls style="margin-top:10px" hidden></audio>
    </div>

    <div class="card">
      <h2>2) PoÅ‚Ä…cz wokal z innym beatem</h2>
      <div class="grid">
        <div>
          <label for="vocalFile">Wokal (np. z kroku 1)</label>
          <input id="vocalFile" type="file" accept="audio/*" />
        </div>
        <div>
          <label for="beatFile">Beat / instrumental</label>
          <input id="beatFile" type="file" accept="audio/*" />
        </div>
      </div>

      <div class="grid" style="margin-top:12px">
        <div>
          <label>GÅ‚oÅ›noÅ›Ä‡ wokalu <span id="gainVocalVal" class="mini">1.00</span></label>
          <input id="gainVocal" type="range" min="0" max="2" step="0.01" value="1" />
        </div>
        <div>
          <label>GÅ‚oÅ›noÅ›Ä‡ beatu <span id="gainBeatVal" class="mini">1.00</span></label>
          <input id="gainBeat" type="range" min="0" max="2" step="0.01" value="1" />
        </div>
      </div>

      <div class="grid" style="margin-top:12px">
        <div>
          <label>PrzesuniÄ™cie wokalu (ms)</label>
          <input id="offsetVocalMs" type="number" value="0" step="10" />
        </div>
        <div>
          <label>PrzesuniÄ™cie beatu (ms)</label>
          <input id="offsetBeatMs" type="number" value="0" step="10" />
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <button id="btnMakeMix" class="btn" disabled>Render miks â†’ pobierz <b>mix.wav</b></button>
        <button id="btnPreviewMix" class="btn secondary" disabled>PodglÄ…d miksu â–¶</button>
      </div>
      <div class="status" id="statusMix">Wgraj oba pliki, aby wÅ‚Ä…czyÄ‡ mix.</div>
      <audio id="previewMix" class="audio" controls style="margin-top:10px" hidden></audio>
    </div>

    <div class="card">
      <h2>Jak to dziaÅ‚a? (skrÃ³t)</h2>
      <ul>
        <li><b>Instrumental</b>: usuwanie Å›rodka (center-cancel): odejmujemy kanaÅ‚y L/R â†’ zostaje gÅ‚Ã³wnie to, co nie jest wyÅ›rodkowane (czÄ™sto podkÅ‚ad).</li>
        <li><b>Wokal</b>: bierzemy kanaÅ‚ Å›rodkowy (L+R)/2 i filtr pasmowy (gÅ‚osy ~120â€“8000 Hz), plus normalizacja.</li>
        <li><b>Miks</b>: resampling do 44.1 kHz, dopasowanie dÅ‚ugoÅ›ci, ciche mieszanie i limiter soft-clip, eksport do WAV.</li>
      </ul>
      <p class="mini">JakoÅ›Ä‡ zaleÅ¼y od miksu oryginaÅ‚u. Do perfekcyjnej separacji potrzebne sÄ… modele AI po stronie serwera.</p>
    </div>
  </div>

  <script>
    // === USTAWIENIA / NARZÄ˜DZIA ===
    const TARGET_SR = 44100; // docelowa czÄ™stotliwoÅ›Ä‡ prÃ³bkowania do renderÃ³w WAV
    let liveCtx;

    function getAudioCtx() {
      if (!liveCtx) liveCtx = new (window.AudioContext || window.webkitAudioContext)();
      return liveCtx;
    }
    async function decodeFileToAudioBuffer(file) {
      const ctx = getAudioCtx();
      const arr = await file.arrayBuffer();
      return await ctx.decodeAudioData(arr.slice(0));
    }
    async function resampleBufferToSR(buffer, targetSR = TARGET_SR) {
      if (buffer.sampleRate === targetSR) return buffer;
      const offline = new OfflineAudioContext(buffer.numberOfChannels, Math.ceil(buffer.duration * targetSR), targetSR);
      const src = offline.createBufferSource();
      src.buffer = buffer;
      src.connect(offline.destination);
      src.start();
      return await offline.startRendering();
    }
    function ensureStereo(buffer) {
      if (buffer.numberOfChannels === 2) return buffer;
      const ctx = getAudioCtx();
      const stereo = ctx.createBuffer(2, buffer.length, buffer.sampleRate);
      const mono = buffer.getChannelData(0);
      stereo.getChannelData(0).set(mono);
      stereo.getChannelData(1).set(mono);
      return stereo;
    }
    function floatTo16BitPCM(float32) {
      const out = new Int16Array(float32.length);
      for (let i = 0; i < float32.length; i++) {
        let s = Math.max(-1, Math.min(1, float32[i]));
        out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
      }
      return out;
    }
    function interleaveLR(left, right) {
      const len = left.length + right.length;
      const out = new Float32Array(len);
      let i = 0, j = 0;
      while (i < left.length && i < right.length) {
        out[j++] = left[i];
        out[j++] = right[i];
        i++;
      }
      return out;
    }
    function audioBufferToWavBlob(buffer) {
      // Eksport 16-bit PCM WAV
      const numCh = Math.min(2, buffer.numberOfChannels);
      const sr = buffer.sampleRate;
      const L = buffer.getChannelData(0);
      const R = numCh > 1 ? buffer.getChannelData(1) : buffer.getChannelData(0);

      const interleaved = interleaveLR(L, R);
      const pcm16 = floatTo16BitPCM(interleaved);
      const byteRate = sr * numCh * 2;

      const wav = new ArrayBuffer(44 + pcm16.byteLength);
      const view = new DataView(wav);

      function writeString(offset, str) { for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i)); }
      let offset = 0;
      writeString(offset, "RIFF"); offset += 4;
      view.setUint32(offset, 36 + pcm16.byteLength, true); offset += 4;
      writeString(offset, "WAVE"); offset += 4;

      writeString(offset, "fmt "); offset += 4;
      view.setUint32(offset, 16, true); offset += 4;              // PCM chunk size
      view.setUint16(offset, 1, true); offset += 2;               // format = PCM
      view.setUint16(offset, numCh, true); offset += 2;
      view.setUint32(offset, sr, true); offset += 4;
      view.setUint32(offset, byteRate, true); offset += 4;
      view.setUint16(offset, numCh * 2, true); offset += 2;       // block align
      view.setUint16(offset, 16, true); offset += 2;              // bits per sample

      writeString(offset, "data"); offset += 4;
      view.setUint32(offset, pcm16.byteLength, true); offset += 4;

      new Int16Array(wav, 44).set(pcm16);

      return new Blob([wav], { type: "audio/wav" });
    }
    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click();
      a.remove(); URL.revokeObjectURL(url);
    }
    function normalizeBuffer(buf, targetPeak = 0.98) {
      const ch0 = buf.getChannelData(0);
      const ch1 = buf.getChannelData(1);
      let peak = 0;
      for (let i = 0; i < ch0.length; i++) {
        peak = Math.max(peak, Math.abs(ch0[i]), Math.abs(ch1[i]));
      }
      if (peak > 0) {
        const g = targetPeak / peak;
        for (let i = 0; i < ch0.length; i++) { ch0[i] *= g; ch1[i] *= g; }
      }
      return buf;
    }

    // === SEPARACJA: Instrumental (center-cancel) ===
    function makeInstrumental(buffer) {
      buffer = ensureStereo(buffer);
      const ctx = getAudioCtx();
      const out = ctx.createBuffer(2, buffer.length, buffer.sampleRate);
      const L = buffer.getChannelData(0);
      const R = buffer.getChannelData(1);
      const oL = out.getChannelData(0);
      const oR = out.getChannelData(1);
      for (let i = 0; i < buffer.length; i++) {
        const mid = (L[i] + R[i]) * 0.5;       // to co poÅ›rodku (czÄ™sto wokal)
        oL[i] = L[i] - mid;                    // zostawiamy boki (accompaniment)
        oR[i] = R[i] - mid;
      }
      return out;
    }

    // === SEPARACJA: Vocals (mid + filtr pasmowy w offline context) ===
    async function makeVocals(buffer) {
      buffer = ensureStereo(buffer);
      const ctx = getAudioCtx();
      // 1) Ekstrakcja kanaÅ‚u MID
      const mid = ctx.createBuffer(1, buffer.length, buffer.sampleRate);
      const L = buffer.getChannelData(0);
      const R = buffer.getChannelData(1);
      const m = mid.getChannelData(0);
      for (let i = 0; i < buffer.length; i++) m[i] = (L[i] + R[i]) * 0.5;

      // 2) Band-pass ~ gÅ‚os (120â€“8000 Hz) + lekka kompresja w OfflineAudioContext
      const offline = new OfflineAudioContext(2, buffer.length, buffer.sampleRate);
      const src = offline.createBufferSource();
      const stereoMid = offline.createBuffer(2, buffer.length, buffer.sampleRate);
      stereoMid.getChannelData(0).set(m);
      stereoMid.getChannelData(1).set(m);
      src.buffer = stereoMid;

      const hp = offline.createBiquadFilter(); hp.type = "highpass"; hp.frequency.value = 120;
      const lp = offline.createBiquadFilter(); lp.type = "lowpass"; lp.frequency.value = 8000;
      const comp = offline.createDynamicsCompressor();
      comp.threshold.setValueAtTime(-16, 0);
      comp.knee.setValueAtTime(24, 0);
      comp.ratio.setValueAtTime(2.5, 0);
      comp.attack.setValueAtTime(0.003, 0);
      comp.release.setValueAtTime(0.250, 0);

      src.connect(hp).connect(lp).connect(comp).connect(offline.destination);
      src.start();
      let rendered = await offline.startRendering();

      // 3) Normalizacja
      rendered = normalizeBuffer(rendered, 0.98);
      return rendered;
    }

    // === MIX: Å‚Ä…czenie dwÃ³ch plikÃ³w (wokal + beat) ===
    async function makeMix(vocalBuf, beatBuf, gainV = 1.0, gainB = 1.0, offsetVms = 0, offsetBms = 0) {
      // Resampling do TARGET_SR
      vocalBuf = await resampleBufferToSR(ensureStereo(vocalBuf), TARGET_SR);
      beatBuf  = await resampleBufferToSR(ensureStereo(beatBuf),  TARGET_SR);

      const sr = TARGET_SR;
      const offsetV = Math.max(0, Math.round(offsetVms/1000 * sr));
      const offsetB = Math.max(0, Math.round(offsetBms/1000 * sr));

      const len = Math.max(vocalBuf.length + offsetV, beatBuf.length + offsetB);
      const ctx = getAudioCtx();
      const out = ctx.createBuffer(2, len, sr);
      const oL = out.getChannelData(0);
      const oR = out.getChannelData(1);

      const vL = vocalBuf.getChannelData(0), vR = vocalBuf.getChannelData(1);
      const bL = beatBuf.getChannelData(0),  bR = beatBuf.getChannelData(1);

      // Sumowanie z wzmocnieniami
      for (let i = 0; i < vL.length; i++) {
        const j = i + offsetV;
        if (j < len) { oL[j] += vL[i] * gainV; oR[j] += vR[i] * gainV; }
      }
      for (let i = 0; i < bL.length; i++) {
        const j = i + offsetB;
        if (j < len) { oL[j] += bL[i] * gainB; oR[j] += bR[i] * gainB; }
      }

      // Soft clip / limiter prosty
      for (let i = 0; i < len; i++) {
        oL[i] = Math.tanh(oL[i]);
        oR[i] = Math.tanh(oR[i]);
      }
      return normalizeBuffer(out, 0.98);
    }

    // === UI / LOGIKA ===
    const el = (id) => document.getElementById(id);
    const songFile = el('songFile');
    const btnInstr = el('btnInstrumental');
    const btnVoc   = el('btnVocals');
    const statusMain = el('statusMain');
    const previewOriginal = el('previewOriginal');

    const vocalFile = el('vocalFile');
    const beatFile = el('beatFile');
    const btnMakeMix = el('btnMakeMix');
    const btnPreviewMix = el('btnPreviewMix');
    const statusMix = el('statusMix');
    const previewMix = el('previewMix');
    const gainVocal = el('gainVocal');
    const gainBeat = el('gainBeat');
    const gainVocalVal = el('gainVocalVal');
    const gainBeatVal = el('gainBeatVal');
    const offsetVocalMs = el('offsetVocalMs');
    const offsetBeatMs = el('offsetBeatMs');

    let loadedSongBuf = null;
    let loadedVocalBuf = null;
    let loadedBeatBuf = null;

    function updateGainsUI(){
      gainVocalVal.textContent = (+gainVocal.value).toFixed(2);
      gainBeatVal.textContent  = (+gainBeat.value).toFixed(2);
    }
    gainVocal.addEventListener('input', updateGainsUI);
    gainBeat.addEventListener('input', updateGainsUI);
    updateGainsUI();

    songFile.addEventListener('change', async () => {
      if (!songFile.files[0]) return;
      statusMain.textContent = 'Dekodowanie...';
      const buf = await decodeFileToAudioBuffer(songFile.files[0]);
      loadedSongBuf = buf;
      btnInstr.disabled = false;
      btnVoc.disabled = false;
      statusMain.textContent = `ZaÅ‚adowano: ${songFile.files[0].name} â€¢ ${buf.numberOfChannels}ch â€¢ ${buf.sampleRate} Hz â€¢ ${(buf.duration).toFixed(1)} s`;
      // podglÄ…d
      const url = URL.createObjectURL(songFile.files[0]);
      previewOriginal.src = url;
      previewOriginal.hidden = false;
      try { await getAudioCtx().resume(); } catch {}
    });

    btnInstr.addEventListener('click', async () => {
      if (!loadedSongBuf) return;
      statusMain.textContent = 'Przetwarzanie: usuwanie wokalu (center-cancel)...';
      const inst = makeInstrumental(loadedSongBuf);
      const inst441 = await resampleBufferToSR(inst, TARGET_SR);
      const blob = audioBufferToWavBlob(inst441);
      downloadBlob(blob, 'instrumental.wav');
      statusMain.textContent = 'Gotowe! Pobrano instrumental.wav';
    });

    btnVoc.addEventListener('click', async () => {
      if (!loadedSongBuf) return;
      statusMain.textContent = 'Przetwarzanie: wydzielanie wokalu...';
      const voc = await makeVocals(loadedSongBuf);
      const voc441 = await resampleBufferToSR(voc, TARGET_SR);
      const blob = audioBufferToWavBlob(voc441);
      downloadBlob(blob, 'vocals.wav');
      statusMain.textContent = 'Gotowe! Pobrano vocals.wav';
    });

    function checkMixAvailability() {
      btnMakeMix.disabled = !(loadedVocalBuf && loadedBeatBuf);
      btnPreviewMix.disabled = !(loadedVocalBuf && loadedBeatBuf);
      statusMix.textContent = (loadedVocalBuf && loadedBeatBuf)
        ? 'Pliki gotowe do miksu.'
        : 'Wgraj oba pliki (wokal i beat).';
    }

    vocalFile.addEventListener('change', async () => {
      if (!vocalFile.files[0]) return;
      statusMix.textContent = 'Dekodowanie wokalu...';
      loadedVocalBuf = await decodeFileToAudioBuffer(vocalFile.files[0]);
      checkMixAvailability();
    });
    beatFile.addEventListener('change', async () => {
      if (!beatFile.files[0]) return;
      statusMix.textContent = 'Dekodowanie beatu...';
      loadedBeatBuf = await decodeFileToAudioBuffer(beatFile.files[0]);
      checkMixAvailability();
    });

    btnMakeMix.addEventListener('click', async () => {
      statusMix.textContent = 'Render miksu do WAV...';
      const mix = await makeMix(
        loadedVocalBuf, loadedBeatBuf,
        parseFloat(gainVocal.value), parseFloat(gainBeat.value),
        parseFloat(offsetVocalMs.value||0), parseFloat(offsetBeatMs.value||0)
      );
      const res = await resampleBufferToSR(mix, TARGET_SR);
      const blob = audioBufferToWavBlob(res);
      downloadBlob(blob, 'mix.wav');
      statusMix.textContent = 'Gotowe! Pobrano mix.wav';
    });

    btnPreviewMix.addEventListener('click', async () => {
      statusMix.textContent = 'Przygotowanie podglÄ…du miksu...';
      const mix = await makeMix(
        loadedVocalBuf, loadedBeatBuf,
        parseFloat(gainVocal.value), parseFloat(gainBeat.value),
        parseFloat(offsetVocalMs.value||0), parseFloat(offsetBeatMs.value||0)
      );
      const res = await resampleBufferToSR(mix, TARGET_SR);
      const blob = audioBufferToWavBlob(res);
      const url = URL.createObjectURL(blob);
      previewMix.src = url;
      previewMix.hidden = false;
      statusMix.textContent = 'PodglÄ…d gotowy.';
      try { await getAudioCtx().resume(); } catch {}
    });

    // iOS/Chrome Autoplay unlock
    window.addEventListener('click', () => { try { getAudioCtx().resume(); } catch {} }, { once:true });
  </script>
</body>
</html>
